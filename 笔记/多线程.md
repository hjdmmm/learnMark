线程简介

线程实现

线程状态

线程同步

线程通信问题

高级主题

# 线程简介

程序运行起来就是进程(process)，是动态的概念

进程中包含若干个线程

线程是cpu调度和执行的单位

真正的多线程：多核cpu

模拟的多线程：cpu切换任务很快，仿佛可以一次性做很多事情

调度器控制线程运行，不能人为干预

# 易错

在java中，同一个进程的线程共享堆内存和方法区内存，但一个线程一个栈

并不是一个方法一个线程，若多个方法在一个栈中则只有一个线程，从上到下顺序执行

# 线程创建

三种方式：

1. Thread class
2. Runnable接口
3. Callable接口

## Thread

自定义线程类继承Thread类

重写run()方法

使用start()方法进行多线程，

start()启动一个分支线程，在JVM中开辟一个新的栈空间，自动调用run()，并且run()在分支栈的最底部，main()方法在主栈最底部

## 实现Runnable接口

不同：将类作为参数传入Thread类中并执行start()方法

推荐使用Runnable接口

## 实现Callable接口

1. 可以抛出异常
2. 有返回值

# 静态代理

真实对象和代理对象都要实现同一个接口

代理对象要代理真实角色

好处：

1. 代理对象可以做很多真实对象做不了的事情
2. 真实对象专注做自己的事情

实现了Runnable接口的类只是一个可运行的类，还不是一个线程类，需要Thread来代理

# lambda表达式

函数式接口：有且只有一个方法的接口

我们可以用lambda表达式创建函数式接口对象

简化过程

1. 外部类
2. 内部类
3. 静态内部类
4. 局部内部类
5. 匿名内部类
6. lambda表达式

# 线程状态

## 创建状态

## 就绪状态

调用了start()方法，表示线程具有抢夺执行权的权利

## 阻塞状态

当一个线程遇到阻塞事件（接收用户键盘输入，sleep()方法等），会放弃之前占有的CPU时间片，进入阻塞状态，接触后进入就绪状态重新抢夺执行权

## 运行状态

run()方法，当之前占有的CPU时间片用完了以后会又进入就绪状态，重新抢夺到CPU执行权以后才能继续执行run()接着运行，即线程可能会在就绪运行之间多次来回切换

## 死亡状态

run()结束

# 线程休眠

让线程进入阻塞状态

每个线程都有一把锁，sleep()不会释放锁

sleep()只能让当前线程进行休眠，即使你在当前线程调用其他线程的sleep()也是让当前线程休眠，被调用的线程不会休眠，因为sleep()是静态方法

interrupt()实例方法中断线程休眠

# 线程调度

## 线程优先级

最低是1，默认是5，最高是10

影响CPU行为

先设置优先级，再启动

有时会出现线程倒置的情况，即优先级低的线程反而先执行，但一般不会

## 线程礼让

yield()

礼让线程，让当前正在执行的线程暂停，但不阻塞

将线程从运行状态转为就绪状态

礼让不一定成功

## 合并线程

t.join()，t线程合并到当前线程，当前线程阻塞，t线程执行完当前线程才能继续执行

插队，会让插队的线程执行完

# 线程安全

数据在多线程并发的环境下存在安全问题的条件：

1. 多线程并发(并发：同一个对象被多个线程同时操作)
2. 有共享数据
3. 共享数据有修改行为

用排队执行解决线程安全问题，线程同步机制

数据安全是第一位，保证数据安全才能谈效率问题

# 线程同步

## 异步编程模型

线程t1和t2各自执行，互不干扰，即多线程并发

## 同步编程模型

在t1执行时必须等待t2线程执行结束，反之亦然，线程执行存在顺序和等待

---

多个线程操作同一个资源，用队列+锁 保证安全



synchronized可以写在三个地方

1. 代码块：自己用锁，synchronized(obj)锁的对象就是变化的量，就是需要增删改的量
2. 实例方法：用this锁，缺陷：将一个大方法声明为synchronized影响效率
3. 静态方法：用类锁



局部变量和常量不会有线程安全问题，成员变量会有

只读对象一般不用锁

# 开发中的线程同步

1. 尽量使用局部变量代替实例变量和静态变量
2. 如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共享了
3. 如果不能使用局部变量，对象也不能创建多个，就只能用synchronized

# 锁

在java中，任何一个对象都有一把锁

线程在运行状态遇到synchronized代码块会进入lockpool(锁池)找对象的锁，并释放掉之前占有的CPU时间片，没找到锁会在锁池中等待(此时可以理解为是一种阻塞状态)，找到锁了会进入就绪状态重新抢夺执行权，

可重入锁

Lock是显式锁，synchronized出了作用域自动释放

## 死锁

某一个同步块，拥有两个以上对象的锁

synchronized在开发中最好不要嵌套使用

# 守护线程

线程分为用户线程和守护线程

虚拟机必须确保用户线程执行完毕

虚拟机不用等待守护线程执行完毕，所有的用户线程结束，守护线程自动结束

如：后台记录操作日志，监控内存，垃圾回收

setDaemon(true)

# 定时器

间隔特定的时间，执行特定的程序

每周进行银行账户总账操作，每天要进行数据的备份操作

高级框架都有定时任务

# wait()和notify()

是Object类的实例方法

wait()方法不是通过线程对象调用的，而是o对象调用的，能让正在o对象上活动的线程进入阻塞状态，notify()同理

o.wait()会让正在o对象上活动的当前线程进入等待状态，并且释放之前占有的o对象的锁

o.notify()方法让正在o对象上等待的线程唤醒，只会通知，不会释放当前占有的o对象的锁

---

- 锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。

- 等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中

当一个线程进入wait之后，就必须等其他线程notify()/notifyAll(),使用notifyAll(),可以唤醒
所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify()只能随机唤醒任意一个。注意，任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行synchronized 中的代码，notifyAll()只是让处于wait的线程重新拥有锁的争夺权，但是只会有一个获得锁并执行。

notify()用得不好容易导致线程都挂起，不去抢锁，产生类似死锁的现象

# 线程协作

## 生产者和消费者模式

一个线程负责生产，一个线程负责消费

生产者和消费者共享仓库，需要考虑仓库的线程安全问题

wait()和notify()建立在synchronized线程同步的基础上

最终要达到生产和消费必须均衡



## 管程法

## 信号灯法

# 线程池

提前创建好多个线程，放入线程池中，使用时直接获取，用完后放回池中

可以避免频繁创建销毁

