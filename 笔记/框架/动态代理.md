# 代理模式概述

为其他对象提供一种代理以控制对这种对象的访问。

## 作用

1. 功能增强
2. 控制访问：代理类不让你访问目标，商家不让用户访问厂家

## 实现代理方式

## 静态代理

代理类手工实现，自己创建一个java类，表示代理类，同时要代理的目标类必须是确定的。

特点：实现简单，容易理解

缺点：当目标类增加了，代理类数量也要成倍增加；当接口功能增加了，或者修改了，影响众多实现类

实现步骤：

1. 创建一个接口，定义卖U盘的方法，表示厂家和商家做的事情
2. 创建厂家类，实现1步骤的接口
3. 创建商家，就是代理，也要实现卖U盘的接口
4. 创建客户端类，调用商家的方法买一个U盘

## 动态代理

在程序执行过程中，使用jdk的反射机制，创造代理类对象，避免静态代理的缺点，换句话说，动态代理是一种创建java对象的能力，可以在程序执行的时候，才出现代理类，不用我们手工写

在静态代理中目标类很多的时候，可以使用动态代理，避免静态代理的缺点

动态代理中目标类即使很多，代理类数量可以很少，修改了接口中的方法，不会影响代理类

# 动态代理的实现

## jdk动态代理

使用java反射包中的类和接口实现动态代理功能

反射包 java.lang.reflect，里面有三个类(接口)：InvocationHandler，Method，Proxy

### InvocationHandle接口

调用处理器

只有一个方法invoke()，表示代理对象要执行的功能代码，代理类要完成的功能就写在invoke()中

代理类完成的功能：调用目标方法，执行目标方法的功能；功能增强，在目标方法调用时，增强功能

方法原型：public Object invoke(Object proxy, Method method, Object[] args);

参数：

proxy：jdk创建的代理对象，无需手动赋值

method：目标类中的方法，jdk提供

args：目标类中参数的方法

---

用法：

1. 创建类实现接口InvocationHandler
2. 重写invoke()

### Method类

目标类中的方法，调用目标类的方法

### Proxy类

核心的对象，用于创建代理对象

核心方法：public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)

参数：

1. loader 类加载器，负责向内存中加载对象，使用反射获取对象的ClassLoader类
2. interfaces 接口，目标对象实现的接口，也是通过反射获取的
3. h：我们自己写的，代理类要完成的功能



## cglib动态代理

cglib是第三方的工具库，创建代理对象，cglib的原理是继承，cglib通过继承目标类，创建他的子类，在子类中重写父类中同名的方法，实现功能的修改